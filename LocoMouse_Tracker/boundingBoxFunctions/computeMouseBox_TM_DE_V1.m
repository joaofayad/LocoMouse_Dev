function [box, cc, I_crop] = computeMouseBox_TM_DE_V1(I,split_line,threshold)

% COMPUTEMOUSEBOX in its different version computes the bounding box around 
% the mouse on a background subtracted image.
% Different setups may demand adjustments.
%
% This script is adapted to be used with a head-free treadmill setup.
%
% !!DO NOT EDIT THIS FILE!! - unless you are the original author.
% FOLLOW INSTRUCTIONS IN "READ_BEFORE_CHANGING_ANYTHING.m"
%
% INPUT:
% I: background subtracted grayscale image.
% split_line: pixel hight dividing the two views.
%
% OUTPUT: 
% - bounding box: a 2x3 matrix for 
%              [br_x    br_yb      br_yt; ...
%               width   height_b   height_t];
                %   with
                %   br_x    = x of bottom right corner
                %   br_yb   = y of bottom half of the image (bottom view)
                %   br_yt   = y of top half of the image (lateral view)
                %   width   = width
                %   height_b= height in bottom half of the image
                %   height_t= height in top half of the image
%               Cordinates refer to the image halves *after cutting*. 
%               In whole image br_yt needs to be added to the split line.
%
% - cc:     2x2 matrix where the i-th column is the 2x1 image coordinates 
%           of the centroid of the bounding in view i (i == 1 is bottom). 
% - I_crop: 2x1 cell with the bottom and top view cropped images.
%
% TREADMILL SPECIFICS:
%   [1] In this script the object detection is exclusively done on the lateral
%       view, because the view through the treadmill makes it very difficult.
%   [2] Due to additional noise around the edges, the side view is padded
%       in a black frame
%   [3] The bounding box width is hardcoded.
%   [4] The final box only uses the bottom right corner of the detected
%       object.
%
% DON'T EDIT THIS FUNCTION, MAKE A COPY AND FOLLOW
%                                         "READ_BEFORE_CHANGING_ANYTHING.m"
%   0. Check different existing functions to find the one that gives you the
%      best result and modify that function.
%   1. Save changes into a copy replacing 'DE' with your initials and
%      change the function name appropriately.
%   2. Ensure the OUTPUT remains in the format described above.
%   3. Comment your changes to allow the next person to understand what you
%      did.
% ------------------------------------------
% DE rewriting Dana's computeMouseBoxNewTest
% ------------------------------------------

if ~exist('threshold','var')
    threshold = [0.01 0.01]; % [side bottom]
elseif length(threshold) == 1 % if only one threshold is set, 
    threshold = [threshold threshold]; % use same threshold for bottom and side view
end

[I_crop{[1 2]}] = splitImage(I,split_line);
    ti = 1;
% [1] for ti = [1 2] this script only uses the side view to determine the box
    I_crop_bw{ti}=imadjust(I_crop{ti});  % brightness and contrast optimization
% [2] [Start] Dana special: padding with a black frame
	if ti==1
        I_crop_bw{ti}(:,[1:46 761:size(I_crop_bw{ti},2)])=0; % remove edges x
        I_crop_bw{ti}([1:100 150:size(I_crop_bw{ti},1)],:)=0; % remove edges y
	end
	% [End] ------------------------------------------------------------
    
    % Image filtering and turning image into a true/false matrix
    H = fspecial('disk',6);
    I_crop_bw{ti}=imfilter(bwareaopen((im2bw(I_crop_bw{ti},threshold(ti))),500),H,'replicate');
    % filling holes
	I_crop_bw{ti} = imfill(I_crop_bw{ti},'holes');
    % get largest object
    CC = bwconncomp(I_crop_bw{ti}); % finds connected objects
    % largest_object: idx of the object with most pixels
    [~,largest_object] = max(cellfun(@(x)(length(x)),CC.PixelIdxList)); 
    % remakeing the bw image to only show the largest_object:
    I_crop_bw{ti} = false(size(I_crop_bw{ti})); 
    I_crop_bw{ti}(CC.PixelIdxList{largest_object}) = true;
    % Get bounding box for the largest object:
    bbox{ti}=regionprops( I_crop_bw{ti},'BoundingBox');
    objs{ti}=vertcat(bbox{ti}.BoundingBox); % [upper_left_X, upper_left_Y width height]
% end

if ~isempty(objs{1})
%     box=[max(objs(:,1)+objs(:,3)),size(I_crop{2},1)-1,165;...
%     400,size(I_crop{2},1),150];

% [3] bounding box width is hardcoded
    tX = (objs{1}(:,1)+objs{1}(:,3));
    width = 400;
    if width >= tX
        width=tX-1;
    end
% [4] The final box only uses the bottom right corner of the detected
%	  object.
    box=[   tX,     size(I_crop{2},1)-1,    size(I_crop{1},1)-1;...
            width,	size(I_crop{2},1),      size(I_crop{1},1)-objs{1}(:,4)];
else
    box=   NaN(2,3);
end
 
box = round(box);

end

